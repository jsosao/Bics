name: Validar Streams

on:
  # Ejecutar manualmente
  workflow_dispatch:
    inputs:
      validate_urls:
        description: '¬øValidar URLs de streaming?'
        required: true
        default: 'true'
        type: choice
        options:
        - 'true'
        - 'false'
      update_file:
        description: '¬øActualizar archivo original?'
        required: true
        default: 'false'
        type: choice
        options:
        - 'true'
        - 'false'
  
  # Ejecutar autom√°ticamente cada d√≠a a las 8:00 AM UTC
  schedule:
    - cron: '0 8 * * *'
  
  # Ejecutar cuando se modifica el archivo apps
  push:
    paths:
      - 'country/apps'

jobs:
  validate-streams:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Validar Streams
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        python << 'EOF'
        import urllib.request
        import urllib.error
        from urllib.parse import urlparse
        import socket
        import re
        import json
        import base64
        import os
        
        def validate_stream_url(url, timeout=10):
            try:
                parsed_url = urlparse(url)
                if not parsed_url.scheme or not parsed_url.netloc:
                    return False
                
                socket.setdefaulttimeout(timeout)
                
                headers = {
                    'User-Agent': 'GitHub-Action-Stream-Validator/1.0'
                }
                
                req = urllib.request.Request(url, headers=headers)
                
                with urllib.request.urlopen(req, timeout=timeout) as response:
                    if 200 <= response.getcode() < 400:
                        return True
                        
                return False
                
            except:
                return False
        
        def parse_stream_block(block_text):
            try:
                title_match = re.search(r'Title:\s*"([^"]*)"', block_text)
                title = title_match.group(1) if title_match else ""
                
                stream_match = re.search(r'Stream:\s*"([^"]*)"', block_text)
                stream_url = stream_match.group(1) if stream_match else ""
                
                artist_match = re.search(r'Artist:\s*"([^"]*)"', block_text)
                artist = artist_match.group(1) if artist_match else "web"
                
                stream_format_match = re.search(r'streamFormat:\s*"([^"]*)"', block_text)
                stream_format = stream_format_match.group(1) if stream_format_match else "hls|mts"
                
                switching_strategy_match = re.search(r'SwitchingStrategy:\s*"([^"]*)"', block_text)
                switching_strategy = switching_strategy_match.group(1) if switching_strategy_match else "full-adaptation"
                
                logo_match = re.search(r'Logo:\s*"([^"]*)"', block_text)
                logo = logo_match.group(1) if logo_match else "https://raw.githubusercontent.com/jsosao/Bics/main/picons/no_logo.png"
                
                live_match = re.search(r'Live:\s*(true|false)', block_text)
                live = live_match.group(1) if live_match else "true"
                
                return {
                    'artist': artist,
                    'title': title,
                    'stream_format': stream_format,
                    'switching_strategy': switching_strategy,
                    'logo': logo,
                    'stream_url': stream_url,
                    'live': live
                }
            except:
                return None
        
        def update_title_status(title, is_online):
            has_x_marker = title.startswith("[X] ")
            
            if is_online:
                if has_x_marker:
                    return title[4:]
                else:
                    return title
            else:
                if not has_x_marker:
                    return f"[X] {title}"
                else:
                    return title
        
        def create_stream_block(stream_data):
            return f'''{{
            Artist: "{stream_data['artist']}"
            Title: "{stream_data['title']}"
            streamFormat: "{stream_data['stream_format']}"
            SwitchingStrategy: "{stream_data['switching_strategy']}"
            Logo: "{stream_data['logo']}"
            Stream: "{stream_data['stream_url']}"
            Live: {stream_data['live']}
        }}'''
        
        # Configuraci√≥n
        file_path = "country/apps"
        validate_urls = "${{ github.event.inputs.validate_urls }}" != "false"
        update_file = "${{ github.event.inputs.update_file }}" == "true"
        
        if "${{ github.event_name }}" == "schedule":
            validate_urls = True
            update_file = True
        
        print("üéØ === VALIDADOR DE STREAMS - GITHUB ACTION ===")
        print(f"üìÑ Procesando archivo: {file_path}")
        print(f"üîç Validar URLs: {validate_urls}")
        print(f"üíæ Actualizar archivo: {update_file}")
        print()
        
        # Leer archivo
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception as e:
            print(f"‚ùå Error al leer el archivo: {str(e)}")
            exit(1)
        
        # Procesar bloques
        blocks = []
        current_block = ""
        brace_count = 0
        
        for line in content.split('\n'):
            line = line.strip()
            if not line:
                continue
                
            current_block += line + '\n'
            brace_count += line.count('{') - line.count('}')
            
            if brace_count == 0 and current_block.strip():
                blocks.append(current_block.strip())
                current_block = ""
        
        if not blocks:
            print("‚ùå No se encontraron bloques v√°lidos")
            exit(1)
        
        print(f"üìä Encontrados {len(blocks)} streams")
        
        updated_blocks = []
        valid_count = 0
        invalid_count = 0
        updated_count = 0
        
        for i, block in enumerate(blocks, 1):
            stream_data = parse_stream_block(block)
            
            if not stream_data:
                updated_blocks.append(block)
                continue
            
            original_title = stream_data['title']
            stream_url = stream_data['stream_url']
            
            if validate_urls and stream_url:
                print(f"üîç Validando {i}/{len(blocks)}: {original_title[:50]}...")
                is_online = validate_stream_url(stream_url)
                
                if is_online:
                    valid_count += 1
                    print("  ‚úÖ Online")
                else:
                    invalid_count += 1
                    print("  ‚ùå Offline")
                
                new_title = update_title_status(original_title, is_online)
                
                if new_title != original_title:
                    updated_count += 1
                    print(f"  üîÑ Actualizado: '{original_title}' ‚Üí '{new_title}'")
                
                stream_data['title'] = new_title
            
            updated_block = create_stream_block(stream_data)
            updated_blocks.append(updated_block)
        
        # Generar contenido final
        final_content = '\n'.join(updated_blocks)
        
        # Estad√≠sticas
        print(f"\nüìà ESTAD√çSTICAS:")
        print(f"   Total streams: {len(blocks)}")
        if validate_urls:
            print(f"   URLs v√°lidas: {valid_count}")
            print(f"   URLs inv√°lidas: {invalid_count}")
            print(f"   T√≠tulos actualizados: {updated_count}")
            if (valid_count + invalid_count) > 0:
                percentage = (valid_count / (valid_count + invalid_count)) * 100
                print(f"   Porcentaje v√°lidas: {percentage:.1f}%")
        
        # Guardar archivo
        if update_file and updated_count > 0:
            try:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(final_content)
                print(f"üíæ Archivo actualizado: {file_path}")
            except Exception as e:
                print(f"‚ùå Error al guardar: {str(e)}")
        
        # Guardar reporte
        with open("validation_report.txt", 'w', encoding='utf-8') as f:
            f.write(f"REPORTE DE VALIDACI√ìN\n")
            f.write(f"====================\n")
            f.write(f"Fecha: $(date)\n")
            f.write(f"Total streams: {len(blocks)}\n")
            if validate_urls:
                f.write(f"URLs v√°lidas: {valid_count}\n")
                f.write(f"URLs inv√°lidas: {invalid_count}\n")
                f.write(f"T√≠tulos actualizados: {updated_count}\n")
        
        print("‚úÖ Proceso completado")
        EOF
    
    - name: Commit cambios
      if: github.event.inputs.update_file == 'true' || github.event_name == 'schedule'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add .
        if git diff --staged --quiet; then
          echo "No hay cambios para commitear"
        else
          git commit -m "ü§ñ Validaci√≥n autom√°tica de streams - $(date)"
          git push
        fi
    
    - name: Upload reporte
      uses: actions/upload-artifact@v4
      with:
        name: validation-report
        path: validation_report.txt
