name: Converter General M3U

on:
  schedule:
    - cron: '50 6 * * 4,5'  # Se ejecuta diariamente a medianoche
  workflow_dispatch:  # Permite ejecución manual

jobs:
  convert:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
        
    - name: Download and convert M3U file
      run: |
        cd $GITHUB_WORKSPACE
        python3 << 'EOF'
        import urllib.request
        import urllib.parse
        import re
        import os
        import json

        # URL del archivo M3U
        url = "https://raw.githubusercontent.com/EdmaviTvBox/1/2b5647e00e0425211bc418821b1d17661e61eace/emvzone.m3u"
        
        # Descargar el archivo
        print("Descargando archivo M3U...")
        with urllib.request.urlopen(url) as response:
            content = response.read().decode('utf-8')
        
        # Obtener lista de logos disponibles en el repositorio
        print("Obteniendo lista de logos disponibles...")
        github_api_url = "https://api.github.com/repos/jsosao/Bics/contents/picons"
        
        try:
            with urllib.request.urlopen(github_api_url) as response:
                picons_data = json.loads(response.read().decode('utf-8'))
                available_logos = {item['name'].lower(): urllib.parse.unquote(item['download_url']) 
                                 for item in picons_data if item['type'] == 'file'}
            print(f"Se encontraron {len(available_logos)} logos disponibles")
        except Exception as e:
            print(f"Error al obtener logos: {e}")
            available_logos = {}
        
        # Logo por defecto
        default_logo = "https://raw.githubusercontent.com/jsosao/Bics/main/picons/no_logo.png"

        def modify_title(title):
            original_title = title
            title_upper = title.upper()
            
            # Si contiene "USA" en cualquier parte del título, reemplazar por "US:" al inicio
            if "USA" in title_upper:
                # Eliminar todas las ocurrencias de USA
                title = re.sub(r'USA', '', title, flags=re.IGNORECASE)
                title = title.strip()
                # Agregar US: al inicio
                title = "US: " + title
                print(f"  Título modificado: '{original_title}' -> '{title}'")
            
            # Si contiene "MEX" en cualquier parte del título, reemplazar por "MX:" al inicio
            elif "MEX" in title_upper:
                # Eliminar todas las ocurrencias de MEX
                title = re.sub(r'MEX', '', title, flags=re.IGNORECASE)
                title = title.strip()
                # Agregar MX: al inicio
                title = "MX: " + title
                print(f"  Título modificado: '{original_title}' -> '{title}'")

            # Si contiene "MEX" en cualquier parte del título, reemplazar por "MX:" al inicio
            elif "ARG" in title_upper:
                # Eliminar todas las ocurrencias de ARG
                title = re.sub(r'ARG', '', title, flags=re.IGNORECASE)
                title = title.strip()
                # Agregar AR: al inicio
                title = "AR: " + title
                print(f"  Título modificado: '{original_title}' -> '{title}'")
            
            return title

        # Función para limpiar el título de prefijos no deseados
        def clean_title(title):

            # Primero aplicar las modificaciones específicas para USA y MEX
            title = modify_title(title)
            
            # Eliminar texto específico (puede estar en cualquier parte del título)
            prefixes_to_remove = ["HD"]
            for prefix in prefixes_to_remove:
                if prefix in title:
                    title = title.replace(prefix, "").strip()
                    print(f"  Patrón '{prefix}' eliminado del título")
            
            # Eliminar todo lo que esté dentro de paréntesis incluyendo los paréntesis
            original_title = title
            title = re.sub(r'\([^)]*\)', '', title)
            if original_title != title:
                print(f"  Contenido entre paréntesis eliminado")
            
            # Limpiar espacios múltiples que puedan quedar
            title = re.sub(r'\s+', ' ', title).strip()
            return title
        
        # Función para encontrar el logo más apropiado
        def find_best_logo(title):
            if not available_logos:
                return default_logo
            
            # Limpiar el título para búsqueda
            title_clean = title.lower()
            # Remover prefijos de país
            title_clean = re.sub(r'^(au|uk|us|ca|es|mx|ar|br|fr)[\s:-]*', '', title_clean)
            # Remover solo algunos caracteres especiales, MANTENER &, +, y otros comunes en nombres de canales
            title_clean = re.sub(r'[^\w\s&+\-]', '', title_clean).strip()
            
            # Extraer palabras clave principales (eliminar números y palabras comunes)
            words = title_clean.split()
            main_keywords = []
            for word in words:
                # Eliminar números solos y palabras muy comunes/cortas
                if (not word.isdigit() and 
                    len(word) > 2 and 
                    word not in ['and', 'the', 'for', 'with', 'from', 'channel']):
                    main_keywords.append(word)
            
            # Si no hay palabras clave principales, usar todas las palabras
            if not main_keywords:
                main_keywords = [w for w in words if len(w) > 1]
            
            print(f"  Palabras clave para búsqueda: {main_keywords}")
            
            # Búsqueda exacta (título completo sin espacios)
            title_search = title_clean.replace(' ', '_')
            for logo_name in available_logos:
                logo_base = logo_name.replace('.png', '').replace('.jpg', '').replace('.jpeg', '')
                if title_search == logo_base:
                    print(f"  Logo encontrado (exacto): {logo_name}")
                    return available_logos[logo_name]
            
            # Búsqueda por palabra clave principal (más importante primero)
            for keyword in main_keywords:
                keyword_underscore = keyword.replace(' ', '_')
                # Buscar logo que coincida exactamente con la palabra clave
                for logo_name in available_logos:
                    logo_base = logo_name.replace('.png', '').replace('.jpg', '').replace('.jpeg', '')
                    # Remover prefijo de país del logo
                    logo_base_no_country = re.sub(r'^(au|uk|us|ca|es|mx|ar|br|fr)_', '', logo_base)
                    
                    # Coincidencia exacta con palabra clave
                    if keyword_underscore == logo_base_no_country:
                        print(f"  Logo encontrado (palabra clave exacta): {logo_name}")
                        return available_logos[logo_name]
                    
                    # Coincidencia con logo que contiene la palabra clave
                    if keyword_underscore in logo_base_no_country:
                        print(f"  Logo encontrado (contiene palabra clave): {logo_name}")
                        return available_logos[logo_name]
            
            # Búsqueda sin prefijo de país en el logo
            for logo_name in available_logos:
                logo_base = logo_name.replace('.png', '').replace('.jpg', '').replace('.jpeg', '')
                # Remover prefijo de país del logo también
                logo_base_no_country = re.sub(r'^(au|uk|us|ca|es|mx|ar|br|fr)_', '', logo_base)
                if title_search == logo_base_no_country:
                    print(f"  Logo encontrado (sin país): {logo_name}")
                    return available_logos[logo_name]
            
            # Búsqueda con espacios en lugar de guiones bajos
            for logo_name in available_logos:
                logo_base = logo_name.replace('.png', '').replace('.jpg', '').replace('.jpeg', '')
                logo_base_no_country = re.sub(r'^(au|uk|us|ca|es|mx|ar|br|fr)_', '', logo_base)
                if title_clean == logo_base_no_country.replace('_', ' '):
                    print(f"  Logo encontrado (con espacios): {logo_name}")
                    return available_logos[logo_name]
            
            # Búsqueda por similitud (para casos como "ESPN 1" -> "espn")
            best_match = None
            best_match_score = 0
            
            for logo_name in available_logos:
                logo_base = logo_name.replace('.png', '').replace('.jpg', '').replace('.jpeg', '')
                logo_base_no_country = re.sub(r'^(au|uk|us|ca|es|mx|ar|br|fr)_', '', logo_base)
                logo_normalized = logo_base_no_country.replace('_', ' ')
                
                # Calcular puntaje de similitud
                score = 0
                
                # Si el título contiene el logo completo
                if logo_normalized in title_clean:
                    score += len(logo_normalized) * 2
                
                # Si el logo contiene palabras clave del título
                for keyword in main_keywords:
                    if keyword in logo_normalized:
                        score += len(keyword) * 3
                
                # Si el logo está contenido en el título
                if logo_normalized in title_clean:
                    score += len(logo_normalized) * 2
                
                # Si tienen palabras en común
                title_words = set(title_clean.split())
                logo_words = set(logo_normalized.split())
                common_words = title_words.intersection(logo_words)
                score += len(common_words) * 5
                
                if score > best_match_score:
                    best_match_score = score
                    best_match = logo_name
            
            # Solo considerar como match válido si el score es suficientemente alto
            if best_match and best_match_score >= 5:
                print(f"  Logo encontrado (mejor coincidencia - score {best_match_score}): {best_match}")
                return available_logos[best_match]
            
            # Búsqueda final: buscar cualquier logo que contenga la primera palabra clave
            if main_keywords:
                first_keyword = main_keywords[0]
                for logo_name in available_logos:
                    logo_base = logo_name.replace('.png', '').replace('.jpg', '').replace('.jpeg', '')
                    logo_base_no_country = re.sub(r'^(au|uk|us|ca|es|mx|ar|br|fr)_', '', logo_base)
                    if first_keyword in logo_base_no_country:
                        print(f"  Logo encontrado (primera palabra clave): {logo_name}")
                        return available_logos[logo_name]
            
            print(f"  Logo no encontrado para '{title}', usando default")
            return default_logo

        
        # Función para determinar el país basado en el título
        def get_country(title):
            title_upper = title.upper()
            
            # Verificar si el título contiene indicadores de país
            if "AU" in title_upper or "AUSTRALIA" in title_upper:
                return "au"
            elif "UK" in title_upper or "BBC" in title_upper or "BRITAIN" in title_upper:
                return "uk"
            elif "US" in title_upper or "USA" in title_upper or "UNITED STATES" in title_upper:
                return "us"
            elif "CA" in title_upper or "CANADA" in title_upper or "CANADIAN" in title_upper:
                return "ca"
            elif "ES" in title_upper or "SPAIN" in title_upper or "ESPAÑA" in title_upper or "ESPAÑOL" in title_upper:
                return "es"
            elif "MX" in title_upper or "MEXICO" in title_upper or "MÉXICO" in title_upper:
                return "mx"
            elif "AR" in title_upper or "ARGENTINA" in title_upper or "ARGENTINO" in title_upper:
                return "ar"
            elif "BR" in title_upper or "BRAZIL" in title_upper or "BRASIL" in title_upper:
                return "br"
            elif "FR" in title_upper or "FRANCE" in title_upper or "FRANÇAIS" in title_upper:
                return "fr"
            else:
                return "us"  # Default
        
        # Función para determinar el tag basado en el group-title
        def get_tag(group_title):
            group_lower = group_title.lower()
            if "sport" in group_lower:
                return "Sports"
            elif "radio" in group_lower:
                return "Radio"
            elif "news" in group_lower:
                return "News"
            elif "movie" in group_lower or "film" in group_lower:
                return "Movies"
            elif "series" in group_lower or "tv show" in group_lower:
                return "Series"
            elif "music" in group_lower:
                return "Music"
            else:
                return "General"
        
        # Función para verificar si el grupo debe ser omitido
        def should_skip_group(group_title):
            group_lower = group_title.lower()
            # Palabras clave que indican grupos a omitir
            skip_keywords = ["radio", "serie", "movie", "extra"]
            return any(keyword in group_lower for keyword in skip_keywords)
        
        # Función para escapar la URL
        def escape_url(url):
            url = url.replace("http://", "http[:[/][/]]")
            url = url.replace("https://", "https[:[/][/]]")
            url = url.replace(".", "[.]")
            url = url.replace("/", "[/]")
            return url
        
        # Parsear el archivo M3U
        lines = content.strip().split('\n')
        entries = []
        
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            
            if line.startswith('#EXTINF:'):
                # Extraer información de la línea EXTINF
                tvg_name_match = re.search(r'tvg-name="([^"]*)"', line)
                tvg_logo_match = re.search(r'tvg-logo="([^"]*)"', line)
                group_title_match = re.search(r'group-title="([^"]*)"', line)
                
                # El título está al final de la línea después de la última coma
                title_match = re.search(r',(.*)$', line)
                
                tvg_name = tvg_name_match.group(1) if tvg_name_match else ""
                tvg_logo = tvg_logo_match.group(1) if tvg_logo_match else ""
                group_title = group_title_match.group(1) if group_title_match else ""
                title = title_match.group(1).strip() if title_match else tvg_name
                
                # Guardar el título original para buscar el logo
                original_title = title
                
                # Limpiar el título y agregar prefijo de país
                title = clean_title(title)
                
                # La siguiente línea debe ser la URL del stream
                i += 1
                if i < len(lines):
                    stream_url = lines[i].strip()
                    
                    # Omitir grupos de Radio, Movies y Series
                    if should_skip_group(group_title):
                        i += 1
                        continue
                    
                    print(f"Procesando: '{title}'")
                    
                    # Buscar el logo más apropiado (usando el título original)
                    best_logo = find_best_logo(original_title)
                    
                    # Crear la entrada
                    entry = {
                        'Artist': 'Cord',
                        'Title': title,
                        'streamFormat': 'hls|mts',
                        'SwitchingStrategy': 'full-adaptation',
                        'Logo': best_logo,
                        'Stream': escape_url(stream_url),
                        'Live': True,
                        'Country': get_country(title),
                        'Tag': get_tag(group_title)
                    }
                    entries.append(entry)
            
            i += 1
        
        # Generar el archivo de salida
        output_lines = []
        for entry in entries:
            output_lines.append('{')
            output_lines.append(f'    Artist: "{entry["Artist"]}"')
            output_lines.append(f'    Title: "{entry["Title"]}"')
            output_lines.append(f'    streamFormat: "{entry["streamFormat"]}"')
            output_lines.append(f'    SwitchingStrategy: "{entry["SwitchingStrategy"]}"')
            output_lines.append(f'    Logo: "{entry["Logo"]}"')
            output_lines.append(f'    Stream: "{entry["Stream"]}"')
            output_lines.append(f'    Live: {str(entry["Live"]).lower()}')
            output_lines.append(f'    Country: "{entry["Country"]}"')
            output_lines.append(f'    Tag: "{entry["Tag"]}"')
            output_lines.append('}')
        
        output_content = '\n'.join(output_lines)
        
        # Guardar el archivo sin extensión
        output_path = "country/others/edmavi"
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(output_content)
        
        print(f"\nArchivo guardado exitosamente en {output_path}")
        print(f"Total de entradas procesadas: {len(entries)}")
        
        # Estadísticas de logos
        logos_default = sum(1 for e in entries if e['Logo'] == default_logo)
        logos_found = len(entries) - logos_default
        print(f"Logos encontrados: {logos_found}")
        print(f"Logos default: {logos_default}")
        EOF
        
    - name: Commit and push changes
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        git add country/others/edmavi
        git diff --staged --quiet || git commit -m "Update edmavi - $(date +'%Y-%m-%d %H:%M:%S')"
        git push
