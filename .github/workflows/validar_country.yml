name: Validar Streams [x] Country

on:
  # Ejecutar manualmente
  workflow_dispatch:
    inputs:
      validate_urls:
        description: 'Â¿Validar URLs de streaming?'
        required: true
        default: 'true'
        type: choice
        options:
        - 'true'
        - 'false'
      update_file:
        description: 'Â¿Actualizar archivo original?'
        required: true
        default: 'false'
        type: choice
        options:
        - 'true'
        - 'false'
  
  # Ejecutar automÃ¡ticamente cada dÃ­a a las 8:00 AM UTC
  schedule:
    - cron: '0 8 * * *'
  
  # Ejecutar cuando se modifica algÃºn archivo en el directorio Country
  push:
    paths:
      - 'country/country/**'

jobs:
  validate-streams-country:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        pip install requests
    
    - name: Create validator script
      run: |
        cat > stream_validator.py << 'EOF'
        import urllib.request
        import urllib.error
        from urllib.parse import urlparse
        import socket
        import re
        import os
        import time
        import sys

        def validate_stream_url(url, timeout=20):
            """Valida una URL de streaming con mÃºltiples estrategias"""
            user_agents = [
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'VLC/3.0.18 LibVLC/3.0.18',
                'FFmpeg/4.4.2'
            ]
            
            parsed_url = urlparse(url)
            if not parsed_url.scheme or not parsed_url.netloc:
                return False, "URL malformada"
            
            socket.setdefaulttimeout(timeout)
            last_error = "Error desconocido"
            
            # Verificar por extensiÃ³n primero
            url_lower = url.lower()
            if any(ext in url_lower for ext in ['.m3u8', '.mpd']):
                ext_type = "HLS" if '.m3u8' in url_lower else "DASH"
                
                for attempt, ua in enumerate(user_agents[:3], 1):
                    success, result = try_request(url, ua, timeout)
                    if success:
                        return True, f"âœ… {ext_type} vÃ¡lido (mÃ©todo {attempt})"
                    else:
                        last_error = result
                        time.sleep(1)
                
                # Si tiene extensiÃ³n vÃ¡lida pero fallÃ³ por restricciones
                if any(indicator in str(last_error).lower() for indicator in ['403', '103', 'reset', 'connection']):
                    return True, f"âœ… {ext_type} vÃ¡lido por extensiÃ³n (acceso restringido)"
            
            # Para otras URLs, intentar validaciÃ³n completa
            for attempt, ua in enumerate(user_agents[:2], 1):
                success, result = try_request(url, ua, timeout, full_validation=True)
                if success:
                    return True, f"âœ… {result} (mÃ©todo {attempt})"
                else:
                    last_error = result
                    time.sleep(1)
            
            # Verificar si parece URL de streaming vÃ¡lida
            error_str = str(last_error).lower()
            if any(error_code in error_str for error_code in ['403', '103', 'reset', 'connection']):
                if any(indicator in url_lower for indicator in [
                    'm3u8', 'mpd', 'stream', 'live', 'hls', 'dash', 'playlist', 'manifest'
                ]):
                    return True, f"âš ï¸ Posible stream vÃ¡lido (acceso restringido)"
            
            return False, last_error

        def try_request(url, user_agent, timeout, full_validation=False):
            """Intenta hacer request con manejo de errores"""
            try:
                headers = {
                    'User-Agent': user_agent,
                    'Accept': '*/*',
                    'Accept-Language': 'en-US,en;q=0.9',
                    'Connection': 'keep-alive'
                }
                
                req = urllib.request.Request(url, headers=headers)
                
                with urllib.request.urlopen(req, timeout=timeout) as response:
                    status_code = response.getcode()
                    
                    if not (200 <= status_code < 400):
                        return False, f"HTTP {status_code}"
                    
                    if full_validation:
                        content_type = response.headers.get('content-type', '').lower()
                        content_sample = response.read(4096).decode('utf-8', errors='ignore')
                        
                        # Verificar contenido de streaming
                        if any(indicator in content_sample.lower() for indicator in [
                            '#extm3u', '#ext-x-', '<mpd', 'urn:mpeg:dash'
                        ]):
                            stream_type = "HLS" if '#extm3u' in content_sample.lower() else "DASH"
                            return True, f"{stream_type} Manifest"
                        elif any(ct in content_type for ct in [
                            'mpegurl', 'dash+xml', 'mp2t', 'octet-stream'
                        ]):
                            return True, "Stream vÃ¡lido por Content-Type"
                    
                    return True, "VÃ¡lido"
                    
            except urllib.error.HTTPError as e:
                return False, f"HTTP {e.code}"
            except Exception as e:
                return False, f"Error: {str(e)[:50]}"

        def parse_stream_block(block_text):
            """Parsea un bloque de stream"""
            try:
                title_match = re.search(r'Title:\s*"([^"]*)"', block_text)
                title = title_match.group(1) if title_match else ""
                
                stream_match = re.search(r'Stream:\s*"([^"]*)"', block_text)
                stream_url = stream_match.group(1) if stream_match else ""
                
                artist_match = re.search(r'Artist:\s*"([^"]*)"', block_text)
                artist = artist_match.group(1) if artist_match else "web"
                
                stream_format_match = re.search(r'streamFormat:\s*"([^"]*)"', block_text)
                stream_format = stream_format_match.group(1) if stream_format_match else "hls|mts"
                
                switching_strategy_match = re.search(r'SwitchingStrategy:\s*"([^"]*)"', block_text)
                switching_strategy = switching_strategy_match.group(1) if switching_strategy_match else "full-adaptation"
                
                logo_match = re.search(r'Logo:\s*"([^"]*)"', block_text)
                logo = logo_match.group(1) if logo_match else "https://raw.githubusercontent.com/jsosao/Bics/main/picons/no_logo.png"
                
                live_match = re.search(r'Live:\s*(true|false)', block_text)
                live = live_match.group(1) if live_match else "true"
                
                return {
                    'artist': artist,
                    'title': title,
                    'stream_format': stream_format,
                    'switching_strategy': switching_strategy,
                    'logo': logo,
                    'stream_url': stream_url,
                    'live': live,
                    'original_block': block_text
                }
            except Exception as e:
                print(f"âš ï¸ Error al parsear bloque: {str(e)}")
                return None

        def update_title_status(title, is_online):
            """Actualiza el estado del tÃ­tulo con marcador [X]"""
            has_x_marker = title.startswith("[X] ")
            
            if is_online:
                return title[4:] if has_x_marker else title
            else:
                return f"[X] {title}" if not has_x_marker else title

        def create_stream_block(stream_data):
            """Crea un bloque de stream actualizado"""
            return f'''{{
            Artist: "{stream_data['artist']}"
            Title: "{stream_data['title']}"
            streamFormat: "{stream_data['stream_format']}"
            SwitchingStrategy: "{stream_data['switching_strategy']}"
            Logo: "{stream_data['logo']}"
            Stream: "{stream_data['stream_url']}"
            Live: {stream_data['live']}
        }}'''

        def main():
            # ConfiguraciÃ³n
            directory_path = "country/country"
            validate_urls = len(sys.argv) > 1 and sys.argv[1] == "true"
            update_file = len(sys.argv) > 2 and sys.argv[2] == "true"
            
            print("ðŸŽ¯ === VALIDADOR DE STREAMS - GITHUB ACTION ===")
            print(f"ðŸ“ Directorio: {directory_path}")
            print(f"ðŸ” Validar URLs: {validate_urls}")
            print(f"ðŸ’¾ Actualizar archivos: {update_file}")
            print()
            
            if not os.path.exists(directory_path):
                print(f"âŒ Directorio {directory_path} no encontrado")
                return 1
            
            # Obtener archivos
            try:
                all_files = os.listdir(directory_path)
                file_paths = [os.path.join(directory_path, f) for f in all_files 
                             if os.path.isfile(os.path.join(directory_path, f)) and not f.startswith('.')]
                
                if not file_paths:
                    print(f"âŒ No se encontraron archivos en {directory_path}")
                    return 1
                
                print(f"ðŸ“‹ Archivos encontrados: {len(file_paths)}")
                
            except Exception as e:
                print(f"âŒ Error al leer directorio: {str(e)}")
                return 1
            
            total_streams = 0
            total_valid = 0
            total_invalid = 0
            total_updated = 0
            
            # Procesar cada archivo
            for file_path in file_paths:
                print(f"\nðŸ“‚ Procesando: {file_path}")
                
                try:
                    # Leer archivo con manejo de codificaciÃ³n
                    content = None
                    for encoding in ['utf-8', 'iso-8859-1', 'windows-1252']:
                        try:
                            with open(file_path, 'r', encoding=encoding) as f:
                                content = f.read()
                            break
                        except UnicodeDecodeError:
                            continue
                    
                    if content is None:
                        print(f"âŒ No se pudo leer {file_path}")
                        continue
                        
                except Exception as e:
                    print(f"âŒ Error al leer {file_path}: {str(e)}")
                    continue
                
                # Procesar bloques
                blocks = []
                current_block = ""
                brace_count = 0
                
                for line in content.split('\n'):
                    line = line.strip()
                    if not line:
                        continue
                        
                    current_block += line + '\n'
                    brace_count += line.count('{') - line.count('}')
                    
                    if brace_count == 0 and current_block.strip():
                        blocks.append(current_block.strip())
                        current_block = ""
                
                if not blocks:
                    print(f"âŒ No se encontraron bloques en {file_path}")
                    continue
                
                print(f"ðŸ“Š Streams encontrados: {len(blocks)}")
                total_streams += len(blocks)
                
                updated_blocks = []
                valid_count = 0
                invalid_count = 0
                updated_count = 0
                
                for i, block in enumerate(blocks, 1):
                    stream_data = parse_stream_block(block)
                    
                    if not stream_data:
                        updated_blocks.append(block)
                        continue
                    
                    original_title = stream_data['title']
                    stream_url = stream_data['stream_url']
                    
                    if validate_urls and stream_url:
                        print(f"ðŸ” Validando {i}/{len(blocks)}: {original_title[:50]}...")
                        
                        is_online, validation_detail = validate_stream_url(stream_url)
                        
                        if is_online:
                            valid_count += 1
                            print(f"  {validation_detail}")
                        else:
                            invalid_count += 1
                            print(f"  âŒ {validation_detail}")
                        
                        new_title = update_title_status(original_title, is_online)
                        
                        if new_title != original_title:
                            updated_count += 1
                            print(f"  ðŸ”„ '{original_title}' â†’ '{new_title}'")
                        
                        stream_data['title'] = new_title
                        time.sleep(1)  # Pausa entre validaciones
                    
                    updated_block = create_stream_block(stream_data)
                    updated_blocks.append(updated_block)
                
                # EstadÃ­sticas del archivo
                print(f"ðŸ“ˆ Resultados: {len(blocks)} streams")
                if validate_urls:
                    print(f"   VÃ¡lidas: {valid_count}, InvÃ¡lidas: {invalid_count}")
                    print(f"   Actualizados: {updated_count}")
                
                total_valid += valid_count
                total_invalid += invalid_count
                total_updated += updated_count
                
                # Guardar archivo si hay cambios
                if update_file and updated_count > 0:
                    try:
                        final_content = '\n'.join(updated_blocks)
                        with open(file_path, 'w', encoding='utf-8') as f:
                            f.write(final_content)
                        print(f"ðŸ’¾ Archivo actualizado: {file_path}")
                    except Exception as e:
                        print(f"âŒ Error al guardar {file_path}: {str(e)}")
            
            # EstadÃ­sticas finales
            print(f"\nðŸŽ¯ === RESUMEN FINAL ===")
            print(f"Total streams: {total_streams}")
            if validate_urls:
                print(f"URLs vÃ¡lidas: {total_valid}")
                print(f"URLs invÃ¡lidas: {total_invalid}")
                print(f"TÃ­tulos actualizados: {total_updated}")
                if (total_valid + total_invalid) > 0:
                    percentage = (total_valid / (total_valid + total_invalid)) * 100
                    print(f"Porcentaje vÃ¡lidas: {percentage:.1f}%")
            
            print("âœ… Proceso completado")
            return 0

        if __name__ == "__main__":
            exit(main())
        EOF
    
    - name: Run Stream Validator
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Determinar parÃ¡metros basado en el tipo de ejecuciÃ³n
        if [ "${{ github.event_name }}" = "schedule" ]; then
          VALIDATE_URLS="true"
          UPDATE_FILE="true"
        else
          VALIDATE_URLS="${{ github.event.inputs.validate_urls || 'true' }}"
          UPDATE_FILE="${{ github.event.inputs.update_file || 'false' }}"
        fi
        
        echo "Ejecutando validador con parÃ¡metros:"
        echo "- Validar URLs: $VALIDATE_URLS"
        echo "- Actualizar archivos: $UPDATE_FILE"
        
        python stream_validator.py "$VALIDATE_URLS" "$UPDATE_FILE"
    
    - name: Commit changes
      if: github.event.inputs.update_file == 'true' || github.event_name == 'schedule'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        if git diff --quiet; then
          echo "No hay cambios para commitear"
        else
          git add country/country/
          git commit -m "ðŸ¤– ActualizaciÃ³n automÃ¡tica de estado de streams [$(date +'%Y-%m-%d %H:%M')]" || exit 0
          git push
        fi
    
    - name: Create summary
      run: |
        echo "## ðŸ“Š Resumen de ValidaciÃ³n de Streams" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Directorio procesado:** country/country" >> $GITHUB_STEP_SUMMARY
        echo "- **Fecha de ejecuciÃ³n:** $(date)" >> $GITHUB_STEP_SUMMARY
        echo "- **ValidaciÃ³n de URLs:** ${{ github.event.inputs.validate_urls || 'true' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **ActualizaciÃ³n de archivos:** ${{ github.event.inputs.update_file || 'false' }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### âœ… Proceso completado exitosamente" >> $GITHUB_STEP_SUMMARY
